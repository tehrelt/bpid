File: .\cmd\stego\main.go
package main
import (
	"bytes"
	"crypto/md5"
	"evteev/bpd/lr6/internal/aes"
	"evteev/bpd/lr6/internal/steno"
	"flag"
	"fmt"
	"image"
	"io"
	"log"
	"log/slog"
	"os"
	"time"
	"golang.org/x/image/bmp"
)
const (
	DEFAULT_INPUT  = ""
	DEFAULT_OUTPUT = ""
	DEFAULT_MODE   = ""
	DEFAULT_KEY    = ""
)
var (
	inputPath  string
	outputPath string
	imagePath  string
	mode       string
	key        string
	debug bool
)
func init() {
	flag.StringVar(&inputPath, "in", DEFAULT_INPUT, "input file")
	flag.StringVar(&outputPath, "out", DEFAULT_OUTPUT, "output file")
	flag.StringVar(&imagePath, "img", DEFAULT_INPUT, "picture .bmp file")
	flag.StringVar(&mode, "mode", DEFAULT_MODE, "mode <(encode|e)|(decode|d)>")
	flag.StringVar(&key, "key", DEFAULT_KEY, "")
	flag.BoolVar(&debug, "debug", false, "debug mode")
}
func main() {
	flag.Parse()
	if debug {
		logfile, err := os.OpenFile(fmt.Sprintf("%s.log", time.Now().Local().Format("2006_01_02T15_04_05")), os.O_TRUNC|os.O_CREATE|os.O_WRONLY, 0644)
		if err != nil {
			panic(fmt.Errorf("cannot create logfile: %w", err))
		}
		defer logfile.Close()
		slog.SetDefault(slog.New(slog.NewJSONHandler(logfile, &slog.HandlerOptions{Level: slog.LevelDebug})))
	}
	if mode == DEFAULT_MODE {
		log.Fatal("mode is required")
	}
	if key == DEFAULT_KEY {
		log.Fatal("key is required")
	}
	if mode != "e" && mode != "encode" && mode != "decode" && mode != "d" {
		log.Fatal("mode must be <(encryption|e)|(decryption|d)>")
	}
	cipher, err := aes.New([]byte(key))
	if err != nil {
		panic(err)
	}
	if mode == "encode" || mode == "e" {
		Encode(cipher)
	} else if mode == "decode" || mode == "d" {
		Decode(cipher)
	}
}
func outname(in, out, mbout string) string {
	if out == "" {
		return mbout
	}
	return out
}
func Encode(cipher *aes.Cipher) {
	if inputPath == DEFAULT_INPUT {
		log.Fatal("input file is required")
	}
	if imagePath == DEFAULT_INPUT {
		log.Fatal("input image file is required")
	}
	in, err := os.Open(inputPath)
	if err != nil {
		panic(err)
	}
	defer in.Close()
	img, err := readBmp(imagePath)
	if err != nil {
		panic(err)
	}
	out, err := encode(in, img, cipher)
	if err != nil {
		panic(err)
	}
	if err := writeBmp(outname(imagePath, outputPath, fmt.Sprintf("%s.embedded", imagePath)), out); err != nil {
		panic(fmt.Errorf("failed to write output file: %w", err))
	}
}
func Decode(cipher *aes.Cipher) {
	if imagePath == DEFAULT_INPUT {
		log.Fatal("input image file is required")
	}
	img, err := readBmp(imagePath)
	if err != nil {
		panic(err)
	}
	decoded, hashr, err := decode(img, cipher)
	if err != nil {
		panic(err)
	}
	content, err := io.ReadAll(decoded)
	if err != nil {
		panic(err)
	}
	hash, err := io.ReadAll(hashr)
	if err != nil {
		panic(err)
	}
	ok, err := verifysum(content, hash)
	if err != nil {
		panic(err)
	}
	if !ok {
		fmt.Printf("хеш-сумма не совпала")
		return
	}
	fmt.Printf("хеш сумма совпадает")
	outfile, err := os.OpenFile(outname(inputPath, outputPath, fmt.Sprintf("%s.extracted", inputPath)), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		panic(err)
	}
	defer outfile.Close()
	slog.Debug("writing result", slog.String("content", string(content)))
	outfile.Write(content)
}
func _md5(in []byte) []byte {
	hash := md5.Sum(in)
	return hash[:]
}
func verifysum(data, expected []byte) (bool, error) {
	actual := _md5(data)
	eq := bytes.Equal(actual, expected)
	slog.Debug("md5 hashsum verified", slog.Any("expected", expected), slog.Any("actual", actual), slog.Any("equal", eq))
	return eq, nil
}
func encode(input io.Reader, img image.Image, cipher *aes.Cipher) (image.Image, error) {
	in, err := io.ReadAll(input)
	if err != nil {
		return nil, fmt.Errorf("failed to open file: %w", err)
	}
	hash := _md5(in)
	saturated := append(in, hash...)
	encrypted, err := cipher.Encrypt(bytes.NewReader(saturated))
	if err != nil {
		return nil, fmt.Errorf("failed to encrypt file data: %w", err)
	}
	steno := steno.NewBMPSteno()
	embeded, err := steno.Embed(img, encrypted)
	if err != nil {
		return nil, fmt.Errorf("failed to embed image: %w", err)
	}
	return embeded, nil
}
func decode(img image.Image, cipher *aes.Cipher) (io.Reader, io.Reader, error) {
	steno := steno.NewBMPSteno()
	encrypted, err := steno.Extract(img)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to extract: %w", err)
	}
	decrypted, err := cipher.Decrypt(encrypted)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to decrypt: %w", err)
	}
	content, err := io.ReadAll(decrypted)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read decrypted: %w", err)
	}
	data := content[:len(content)-md5.Size]
	hash := content[len(content)-md5.Size:]
	return bytes.NewReader(data), bytes.NewReader(hash), nil
}
func readBmp(filename string) (image.Image, error) {
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return bmp.Decode(f)
}
func writeBmp(filename string, data image.Image) error {
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()
	return bmp.Encode(f, data)
}

==================================================
File: .\internal\aes\aes.go
package aes
import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"errors"
	"io"
)
var (
	ErrInvalidKey = errors.New("invalid key size. key must be 16, 24, 32 byte len")
)
type Cipher struct {
	key       []byte
	block     cipher.Block
	blockSize int
}
// New initializes a new Cipher with the provided key.
func New(key []byte) (*Cipher, error) {
	if len(key) != 16 && len(key) != 24 && len(key) != 32 {
		return nil, ErrInvalidKey
	}
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}
	return &Cipher{
		key:       key,
		block:     block,
		blockSize: aes.BlockSize,
	}, nil
}
func (c *Cipher) Encrypt(in io.Reader) (io.Reader, error) {
	input, err := io.ReadAll(in)
	if err != nil {
		return nil, err
	}
	input = pad(input, c.blockSize)
	output := make([]byte, len(input)+c.blockSize)
	iv := output[:c.blockSize]
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		return nil, err
	}
	encrypter := cipher.NewCBCEncrypter(c.block, iv)
	encrypter.CryptBlocks(output[c.blockSize:], input)
	return bytes.NewReader(output), nil
}
func (c *Cipher) Decrypt(in io.Reader) (io.Reader, error) {
	input, err := io.ReadAll(in)
	if err != nil {
		return nil, err
	}
	iv := input[:c.blockSize]
	block := cipher.NewCBCDecrypter(c.block, iv)
	input = input[c.blockSize:]
	block.CryptBlocks(input, input)
	output := unpad(input)
	return bytes.NewReader(output), nil
}
func pad(in []byte, blockSize int) []byte {
	padding := blockSize - len(in)%blockSize
	padText := bytes.Repeat([]byte{byte(padding)}, padding)
	return append(in, padText...)
}
func unpad(in []byte) []byte {
	length := len(in)
	unpadding := int(in[length-1])
	return in[:length-unpadding]
}

==================================================
File: .\internal\aes\aes_test.go
package aes_test
import (
	"evteev/bpd/lr6/internal/aes"
	"io"
	"strings"
	"testing"
)
func TestKeySizeError(t *testing.T) {
	cases := []struct {
		name string
		key  string
	}{
		{"len<16", "reltrlet"},
		{"16<len<24", "reltreltreltreltrelt"},
		{"24<len<32", "reltreltreltreltreltreltreltreltreltreltrelt"},
		{"32<len", "reltreltreltreltreltreltreltreltreltreltreltreltrelt"},
	}
	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			if _, err := aes.New([]byte(c.key)); err != aes.ErrInvalidKey {
				t.Error("expected error for key size, got nil")
			}
		})
	}
}
func TestCipher(t *testing.T) {
	cases := []struct {
		name string
		key  string
		in   string
	}{
		{"aes128", "examplekey123456", "lorem ipsum"},
		{"aes128", "examplekey123456", "ofjwqofpgjwqfo[pwqjfo[wqjfopwqjfowqphjfwqoiphfqwpoihfqwpofhqwopfhqwopf]]"},
		{"aes128", "examplekey123456", "12345678gkpewg goewjpg poewjgepwp[g mnewpgo jnewgpo ewngpnewpg jnjewpng ewping ewipng ewing iewng iewng ioweng ing iowe]"},
		{"aes128", "examplekey123456", "ogeqjgojeqgopenjgope ngeqpogn oeqpng poeqng poeqng poegeqpo"},
		{"aes128", "examplekey123456", "ofnmewqopfnqwo pfnwqfoiphn 2-09 fh192f h1-2 f21 f2=1 f1212="},
		{"aes128", "examplekey123456", "loaldakfjwqpfowqhjfoqwfhjwqfoqwopfjhwq"},
		{"aes192", "a24bytelongkeyforaes192m", "hello world"},
		{"aes256", "a32bytelongkeyforaesencryption12", `module evteev/bpd/lr6
go 1.22.1
require golang.org/x/image v0.21.0
`},
	}
	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			cipher, err := aes.New([]byte(c.key))
			if err != nil {
				t.Errorf("failed to create cipher: %v", err)
			}
			encrypted, err := cipher.Encrypt(strings.NewReader(c.in))
			if err != nil {
				t.Errorf("failed to encrypt: %v", err)
			}
			decrypted, err := cipher.Decrypt(encrypted)
			if err != nil {
				t.Errorf("failed to decrypt: %v", err)
			}
			out, err := io.ReadAll(decrypted)
			if err != nil {
				t.Errorf("failed to read decrypted: %v", err)
			}
			if string(out) != c.in {
				t.Errorf("decrypted value does not match input: got %s, want %s", decrypted, c.in)
			}
			t.Logf("in:  %s", c.in)
			t.Logf("out: %s", string(out))
		})
	}
}

==================================================
File: .\internal\steno\bmp.go
package steno
import (
	"bytes"
	"encoding/binary"
	"fmt"
	"image"
	"image/color"
	"io"
	"log/slog"
)
type bmpSteno struct {
}
func NewBMPSteno() Steno {
	return &bmpSteno{}
}
// Embed implements Steno.
func (b *bmpSteno) Embed(img image.Image, reader io.Reader) (*image.RGBA, error) {
	log := slog.With(slog.String("fn", "Embed"))
	data, err := io.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	sizebuf := make([]byte, 4)
	binary.LittleEndian.PutUint32(sizebuf, uint32(len(data)))
	data = append(sizebuf, data...)
	dsize := len(data)
	log.Debug("write data", slog.Any("data", data), slog.Int("size", dsize))
	bounds := img.Bounds()
	width, height := bounds.Max.X, bounds.Max.Y
	out := image.NewRGBA(image.Rect(0, 0, width, height))
	var di, bi int
	for y := 0; y < height; y++ {
		for x := 0; x < width; x++ {
			r, g, b, a := img.At(x, y).RGBA()
			if di < dsize {
				rNew := (r & 0xFFFC) | (uint32(data[di]) >> bi & 0x03)
				bi += 2
				if bi >= 8 {
					bi = 0
					log.Debug("written byte", slog.String("val", string(data[di])), slog.Int("di", di), slog.Int("dsize", dsize))
					di++
				}
				out.SetRGBA(x, y, color.RGBA{uint8(rNew), uint8(g >> 8), uint8(b >> 8), uint8(a >> 8)})
			} else {
				out.SetRGBA(x, y, color.RGBA{uint8(r >> 8), uint8(g >> 8), uint8(b >> 8), uint8(a >> 8)})
			}
		}
	}
	if di < dsize {
		return nil, fmt.Errorf("not such space")
	}
	return out, nil
}
// Extract implements Steno.
func (b *bmpSteno) Extract(in image.Image) (io.Reader, error) {
	log := slog.With(slog.String("fn", "Extract"))
	bounds := in.Bounds()
	width, height := bounds.Max.X, bounds.Max.Y
	sizespace := 4
	sizebuf := make([]byte, sizespace)
	var dataidx, bitidx int
	for y := 0; y < height && dataidx < sizespace; y++ {
		for x := 0; x < width && dataidx < sizespace; x++ {
			r, _, _, _ := in.At(x, y).RGBA()
			sizebuf[dataidx] |= byte(r&0x03) << byte(bitidx)
			bitidx += 2
			if bitidx >= 8 {
				bitidx = 0
				log.Debug("read byte", slog.Int("x", x), slog.Int("y", y), slog.Int("dataidx", dataidx), slog.Int("bitidx", bitidx), slog.Any("val", sizebuf[dataidx]))
				dataidx++
			}
		}
	}
	datasize := binary.LittleEndian.Uint32(sizebuf) + uint32(sizespace)
	log.Debug("extracted size", slog.Int("size", int(datasize)))
	dataidx = 0
	bitidx = 0
	data := make([]byte, datasize)
	for y := 0; y < height && dataidx < int(datasize); y++ {
		for x := 0; x < width && dataidx < int(datasize); x++ {
			r, _, _, _ := in.At(x, y).RGBA()
			data[dataidx] |= byte(r&0x03) << bitidx
			bitidx += 2
			if bitidx >= 8 {
				bitidx = 0
				log.Debug("read byte", slog.Int("x", x), slog.Int("y", y), slog.Int("dataidx", dataidx), slog.Int("bitidx", bitidx), slog.Any("val", data[dataidx]))
				dataidx++
			}
		}
	}
	if dataidx < int(datasize) {
		return nil, fmt.Errorf("cannot extract data")
	}
	log.Debug("extracted data", slog.Any("data", data[sizespace:]))
	return bytes.NewReader(data[4:]), nil
}

==================================================
File: .\internal\steno\bmp_test.go
package steno_test
import (
	"bytes"
	"evteev/bpd/lr6/internal/steno"
	"image"
	"image/color"
	"image/draw"
	"io"
	"log/slog"
	"os"
	"strings"
	"testing"
)
func generateImage(width, height int, imgColor color.Color) image.Image {
	// Create a new blank RGBA image with the specified dimensions.
	img := image.NewRGBA(image.Rect(0, 0, width, height))
	// Fill the image with the given color.
	draw.Draw(img, img.Bounds(), &image.Uniform{imgColor}, image.Point{}, draw.Src)
	return img
}
func compareReaders(r1, r2 io.Reader) (bool, error) {
	const chunkSize = 1024 // Define the chunk size to read data in parts.
	buf1 := make([]byte, chunkSize)
	buf2 := make([]byte, chunkSize)
	for {
		// Read chunks from both readers.
		n1, err1 := r1.Read(buf1)
		n2, err2 := r2.Read(buf2)
		// If the number of bytes read is different, the readers are not equal.
		if n1 != n2 {
			return false, nil
		}
		// If both reached EOF, the readers are equal.
		if err1 == io.EOF && err2 == io.EOF {
			return true, nil
		}
		// If one reached EOF but the other didn't, they are not equal.
		if (err1 == io.EOF || err2 == io.EOF) && err1 != err2 {
			return false, nil
		}
		// If there are other read errors, return the error.
		if err1 != nil && err1 != io.EOF {
			return false, err1
		}
		if err2 != nil && err2 != io.EOF {
			return false, err2
		}
		// Compare the bytes read from both readers.
		if !bytes.Equal(buf1[:n1], buf2[:n2]) {
			return false, nil
		}
	}
}
func TestBmpSteno(t *testing.T) {
	cases := []struct {
		name string
		in   string
	}{
		{"t", "1"},
		{"t", "maxim bogomolov"},
		{"t", "fdwoqjfowpqjnfwqopfjnqwpofhwqopfopqwjof"},
		{"t", "lol"},
	}
	img := generateImage(200, 200, color.Black)
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelDebug})))
	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			steno := steno.NewBMPSteno()
			embed, _ := steno.Embed(img, strings.NewReader(c.in))
			extracted, _ := steno.Extract(embed)
			actual, _ := io.ReadAll(extracted)
			equals := strings.Compare(string(c.in), string(actual)) == 0
			if !equals {
				t.Logf("in:  %s", c.in)
				t.Logf("out: %s", actual)
				t.Errorf("reader dont equals")
			}
		})
	}
}

==================================================
File: .\internal\steno\steno.go
package steno
import (
	"image"
	"io"
)
type Steno interface {
	Embed(in image.Image, data io.Reader) (*image.RGBA, error)
	Extract(in image.Image) (io.Reader, error)
}

==================================================
