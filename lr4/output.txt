File: .\cmd\aes\main.go
package main
import (
	"evteev/bpid/lr4/internal/aes"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
)
const (
	DEFAULT_INPUT  = ""
	DEFAULT_OUTPUT = ""
	DEFAULT_MODE   = ""
	DEFAULT_KEY    = ""
)
var (
	inputPath  string
	outputPath string
	mode       string
	key        string
)
func init() {
	flag.StringVar(&inputPath, "in", DEFAULT_INPUT, "input file")
	flag.StringVar(&outputPath, "out", DEFAULT_OUTPUT, "output file")
	flag.StringVar(&mode, "mode", DEFAULT_MODE, "mode <(encrypt|e)|(decrypt|d)>")
	flag.StringVar(&key, "key", DEFAULT_KEY, "")
}
func main() {
	flag.Parse()
	if inputPath == DEFAULT_INPUT {
		log.Fatal("input file is required")
	}
	if outputPath == DEFAULT_OUTPUT {
		log.Fatal("output file is required")
	}
	if mode == DEFAULT_MODE {
		log.Fatal("mode is required")
	}
	if key == DEFAULT_KEY {
		log.Fatal("key is required")
	}
	if mode != "e" && mode != "encrypt" && mode != "decrypt" && mode != "d" {
		log.Fatal("mode must be <(encryption|e)|(decryption|d)>")
	}
	cipher, err := aes.New([]byte(key))
	if err != nil {
		log.Fatalf("failed to create cipher: %v", err)
	}
	in, err := os.Open(inputPath)
	if err != nil {
		panic("cannot open file")
	}
	defer in.Close()
	var out io.Reader
	if mode == "encrypt" || mode == "e" {
		out, err = cipher.Encrypt(in)
		if err != nil {
			panic(fmt.Sprintf("cannot encrypt file: %v", err.Error()))
		}
	} else if mode == "decrypt" || mode == "d" {
		out, err = cipher.Decrypt(in)
		if err != nil {
			panic(fmt.Sprintf("cannot decrypt file: %s", err.Error()))
		}
	} else {
		panic("invalid mode")
	}
	outfile, err := os.OpenFile(outputPath, os.O_WRONLY|os.O_CREATE, 0666)
	if err != nil {
		panic("cannot open output file")
	}
	defer outfile.Close()
	if _, err := io.Copy(outfile, out); err != nil {
		panic("cannot write to output file")
	}
}

==================================================
File: .\cmd\dsa\main.go
package main
import (
	"errors"
	"evteev/bpid/lr4/internal/dsa"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
)
const (
	DEFAULT_INPUT  = ""
	DEFAULT_OUTPUT = ""
	DEFAULT_MODE   = ""
	DEFAULT_KEY    = ""
)
var (
	inputPath      string
	signaturePath  string
	mode           string
	privateKeyPath string
	publicKeyPath  string
)
func init() {
	flag.StringVar(&inputPath, "in", DEFAULT_INPUT, "path to input file")
	flag.StringVar(&signaturePath, "sign", DEFAULT_OUTPUT, "path to signature")
	flag.StringVar(&mode, "mode", DEFAULT_MODE, "mode <(sign|s)|(verify|v)>")
	flag.StringVar(&privateKeyPath, "priv", DEFAULT_KEY, "path to private key. need for sign")
	flag.StringVar(&publicKeyPath, "pub", DEFAULT_KEY, "path to public key. need for verify")
}
func main() {
	flag.Parse()
	if mode == DEFAULT_MODE {
		log.Fatal("mode is required")
	}
	if mode == "s" || mode == "sign" {
		if inputPath == DEFAULT_INPUT {
			log.Fatal("input file is required")
		}
		if signaturePath == DEFAULT_OUTPUT {
			signaturePath = inputPath + ".sig"
		}
		if privateKeyPath == DEFAULT_KEY {
			log.Fatal("private key is required")
		}
		priv, err := dsa.ExtractPrivateKeyFromFile(privateKeyPath)
		if err != nil {
			panic(fmt.Errorf("failed to read private key: %w", err))
		}
		signer := dsa.NewSigner(priv)
		if err := sign(inputPath, signaturePath, signer); err != nil {
			panic(fmt.Errorf("failed to sign: %w", err))
		}
	} else if mode == "v" || mode == "verify" {
		if inputPath == DEFAULT_INPUT {
			log.Fatal("input file is required")
		}
		if signaturePath == DEFAULT_OUTPUT {
			log.Fatal("output file is required")
		}
		if publicKeyPath == DEFAULT_KEY {
			log.Fatal("public key is required")
		}
		pub, err := dsa.ExtractPublicKeyFromFile(publicKeyPath)
		if err != nil {
			panic(fmt.Sprintf("failed to read public key: %v", err))
		}
		verifier := dsa.NewVerifier(pub)
		if err := verify(inputPath, signaturePath, verifier); err != nil {
			panic(fmt.Errorf("failed to verify: %w", err))
		}
	} else {
		panic(fmt.Errorf("unknown mode: %s", mode))
	}
}
func verify(inputPath, signaturePath string, verifier *dsa.Verifier) error {
	in, err := os.Open(inputPath)
	if err != nil {
		return fmt.Errorf("cannot open input file: %w", err)
	}
	defer in.Close()
	sign, err := os.Open(signaturePath)
	if err != nil {
		return fmt.Errorf("cannot open signature file: %w", err)
	}
	defer sign.Close()
	if err := verifier.Verify(in, sign); err != nil {
		if errors.Is(err, dsa.ErrSignatureMismatch) {
			fmt.Printf("Подпись не совпадает")
			return nil
		} else if errors.Is(err, dsa.ErrSignatureVerificationFailed) {
			fmt.Printf("Подпись не прошла проверку")
			return nil
		} else {
			return err
		}
	}
	fmt.Printf("Подпись верна")
	return nil
}
func sign(inputPath, signaturePath string, signer *dsa.Signer) error {
	in, err := os.Open(inputPath)
	if err != nil {
		return fmt.Errorf("cannot open input file: %w", err)
	}
	defer in.Close()
	signature, err := signer.Sign(in)
	if err != nil {
		return fmt.Errorf("cannot sign: %w", err)
	}
	outfile, err := os.OpenFile(signaturePath, os.O_WRONLY|os.O_CREATE, 0666)
	if err != nil {
		return fmt.Errorf("cannot open output file: %w", err)
	}
	if _, err := io.Copy(outfile, signature); err != nil {
		return fmt.Errorf("cannot copy: %w", err)
	}
	return nil
}

==================================================
File: .\cmd\rsa\main.go
package main
import (
	"evteev/bpid/lr4/internal/rsa"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
)
const (
	DEFAULT_INPUT  = ""
	DEFAULT_OUTPUT = ""
	DEFAULT_MODE   = ""
	DEFAULT_KEY    = ""
)
var (
	inputPath      string
	outputPath     string
	mode           string
	privateKeyPath string
	publicKeyPath  string
)
func init() {
	flag.StringVar(&inputPath, "in", DEFAULT_INPUT, "input file")
	flag.StringVar(&outputPath, "out", DEFAULT_OUTPUT, "output file")
	flag.StringVar(&mode, "mode", DEFAULT_MODE, "mode <(encrypt|e)|(decrypt|d)>")
	flag.StringVar(&privateKeyPath, "priv", DEFAULT_KEY, "path to private key")
	flag.StringVar(&publicKeyPath, "pub", DEFAULT_KEY, "path to public key")
}
func main() {
	flag.Parse()
	if inputPath == DEFAULT_INPUT {
		log.Fatal("input file is required")
	}
	if outputPath == DEFAULT_OUTPUT {
		log.Fatal("output file is required")
	}
	if mode == DEFAULT_MODE {
		log.Fatal("mode is required")
	}
	if privateKeyPath == DEFAULT_KEY {
		log.Fatal("private key is required")
	}
	if publicKeyPath == DEFAULT_KEY {
		log.Fatal("public key is required")
	}
	if mode != "e" && mode != "encrypt" && mode != "decrypt" && mode != "d" {
		log.Fatal("mode must be <(encryption|e)|(decryption|d)>")
	}
	priv, err := rsa.ExtractPrivateKeyFromFile(privateKeyPath)
	if err != nil {
		panic(fmt.Sprintf("failed to read private key: %v", err))
	}
	pub, err := rsa.ExtractPublicKeyFromFile(publicKeyPath)
	if err != nil {
		panic(fmt.Sprintf("failed to read public key: %v", err))
	}
	cipher := rsa.New(priv, pub)
	in, err := os.Open(inputPath)
	if err != nil {
		panic(fmt.Sprintf("failed to open input file: %v", err))
	}
	defer in.Close()
	var out io.Reader
	if mode == "encrypt" || mode == "e" {
		out, err = cipher.Encrypt(in)
		if err != nil {
			panic(fmt.Sprintf("cannot encrypt file: %v", err.Error()))
		}
	} else if mode == "decrypt" || mode == "d" {
		out, err = cipher.Decrypt(in)
		if err != nil {
			panic(fmt.Sprintf("cannot decrypt file: %s", err.Error()))
		}
	} else {
		panic("invalid mode")
	}
	outfile, err := os.OpenFile(outputPath, os.O_WRONLY|os.O_CREATE, 0666)
	if err != nil {
		panic("cannot open output file")
	}
	defer outfile.Close()
	if _, err := io.Copy(outfile, out); err != nil {
		panic("cannot write to output file")
	}
}

==================================================
File: .\internal\aes\aes.go
package aes
import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"errors"
	"io"
)
var (
	ErrInvalidKey = errors.New("invalid key size. key must be 16, 24, 32 byte len")
)
type Cipher struct {
	key       []byte
	block     cipher.Block
	nonceSize int
}
// New initializes a new Cipher with the provided key.
func New(key []byte) (*Cipher, error) {
	if len(key) != 16 && len(key) != 24 && len(key) != 32 {
		return nil, ErrInvalidKey
	}
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}
	return &Cipher{
		key:       key,
		block:     block,
		nonceSize: aes.BlockSize,
	}, nil
}
func (c *Cipher) Encrypt(in io.Reader) (out io.Reader, err error) {
	nonce := make([]byte, c.nonceSize)
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, err
	}
	stream := cipher.NewCFBEncrypter(c.block, nonce)
	out = &cipher.StreamReader{S: stream, R: in}
	output := make([]byte, c.nonceSize)
	copy(output, nonce)
	return io.MultiReader(bytes.NewReader(output), out), nil
}
func (c *Cipher) Decrypt(in io.Reader) (out io.Reader, err error) {
	nonce := make([]byte, c.nonceSize)
	if _, err := io.ReadFull(in, nonce); err != nil {
		return nil, err
	}
	stream := cipher.NewCFBDecrypter(c.block, nonce)
	out = &cipher.StreamReader{S: stream, R: in}
	return out, nil
}

==================================================
File: .\internal\aes\aes_test.go
package aes_test
import (
	"evteev/bpid/lr4/internal/aes"
	"io"
	"strings"
	"testing"
)
func TestKeySizeError(t *testing.T) {
	cases := []struct {
		name string
		key  string
	}{
		{"len<16", "reltrlet"},
		{"16<len<24", "reltreltreltreltrelt"},
		{"24<len<32", "reltreltreltreltreltreltreltreltreltreltrelt"},
		{"32<len", "reltreltreltreltreltreltreltreltreltreltreltreltrelt"},
	}
	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			if _, err := aes.New([]byte(c.key)); err != aes.ErrInvalidKey {
				t.Error("expected error for key size, got nil")
			}
		})
	}
}
func TestCipher(t *testing.T) {
	cases := []struct {
		name string
		key  string
		in   string
	}{
		{"aes128", "examplekey123456", "lorem ipsum"},
		{"aes192", "a24bytelongkeyforaes192m", "hello world"},
		{"aes256", "a32bytelongkeyforaesencryption12", "maxim bogomolov"},
	}
	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			cipher, err := aes.New([]byte(c.key))
			if err != nil {
				t.Errorf("failed to create cipher: %v", err)
			}
			encrypted, err := cipher.Encrypt(strings.NewReader(c.in))
			if err != nil {
				t.Errorf("failed to encrypt: %v", err)
			}
			decrypted, err := cipher.Decrypt(encrypted)
			if err != nil {
				t.Errorf("failed to decrypt: %v", err)
			}
			out, err := io.ReadAll(decrypted)
			if err != nil {
				t.Errorf("failed to read decrypted: %v", err)
			}
			if string(out) != c.in {
				t.Errorf("decrypted value does not match input: got %s, want %s", decrypted, c.in)
			}
		})
	}
}

==================================================
File: .\internal\dsa\dsa.go
package dsa
import (
	"bytes"
	dsa "crypto/ed25519"
	"crypto/sha1"
	"errors"
	"fmt"
	"io"
)
var (
	ErrSignatureVerificationFailed = errors.New("signature failed")
	ErrSignatureMismatch           = errors.New("signatures mismatch")
)
type Signer struct {
	key dsa.PrivateKey
}
type Verifier struct {
	key dsa.PublicKey
}
func NewSigner(key dsa.PrivateKey) *Signer {
	return &Signer{
		key: key,
	}
}
func NewVerifier(key dsa.PublicKey) *Verifier {
	return &Verifier{
		key: key,
	}
}
func (s *Signer) Sign(in io.Reader) (io.Reader, error) {
	hasher := sha1.New()
	if _, err := io.Copy(hasher, in); err != nil {
		return nil, err
	}
	hashed := hasher.Sum(nil)
	signature := dsa.Sign(s.key, hashed)
	return bytes.NewReader(signature), nil
}
func (v *Verifier) Verify(in io.Reader, sign io.Reader) error {
	hasher := sha1.New()
	if _, err := io.Copy(hasher, in); err != nil {
		return err
	}
	hashed := hasher.Sum(nil)
	signature, err := io.ReadAll(sign)
	if err != nil {
		return fmt.Errorf("failed to read a signature: %w", err)
	}
	if !dsa.Verify(v.key, hashed, signature) {
		return ErrSignatureVerificationFailed
	}
	return nil
}

==================================================
File: .\internal\dsa\extract.go
package dsa
import (
	dsa "crypto/ed25519"
	"crypto/x509"
	"encoding/pem"
	"errors"
	"fmt"
	"os"
)
func ExtractPrivateKeyFromFile(path string) (dsa.PrivateKey, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	block, _ := pem.Decode(data)
	if block == nil || block.Type != "PRIVATE KEY" {
		return nil, fmt.Errorf("failed to decode PEM block containing private key: block.Type = %s", block.Type)
	}
	privKey, err := x509.ParsePKCS8PrivateKey(block.Bytes)
	if err != nil {
		return nil, fmt.Errorf("failed to parse: %w", err)
	}
	pkey, ok := privKey.(dsa.PrivateKey)
	if !ok {
		return nil, fmt.Errorf("not a DSA private key")
	}
	return pkey, nil
}
func ExtractPublicKeyFromFile(path string) (dsa.PublicKey, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	block, _ := pem.Decode(data)
	if block == nil || block.Type != "PUBLIC KEY" {
		return nil, errors.New("failed to decode PEM block containing public key")
	}
	pubKey, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		return nil, err
	}
	pub, ok := pubKey.(dsa.PublicKey)
	if !ok {
		return nil, errors.New("not an DSA public key")
	}
	return pub, nil
}

==================================================
File: .\internal\rsa\extract.go
package rsa
import (
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"errors"
	"fmt"
	"os"
)
func ExtractPrivateKeyFromFile(path string) (*rsa.PrivateKey, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	block, _ := pem.Decode(data)
	if block == nil || block.Type != "PRIVATE KEY" {
		return nil, fmt.Errorf("failed to decode PEM block containing private key: block.Type = %s", block.Type)
	}
	privKey, err := x509.ParsePKCS8PrivateKey(block.Bytes)
	if err != nil {
		return nil, err
	}
	pkey, ok := privKey.(*rsa.PrivateKey)
	if !ok {
		return nil, fmt.Errorf("not a private key")
	}
	return pkey, nil
}
func ExtractPublicKeyFromFile(path string) (*rsa.PublicKey, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	block, _ := pem.Decode(data)
	if block == nil || block.Type != "PUBLIC KEY" {
		return nil, errors.New("failed to decode PEM block containing public key")
	}
	pubKey, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		return nil, err
	}
	rsaPubKey, ok := pubKey.(*rsa.PublicKey)
	if !ok {
		return nil, errors.New("not an RSA public key")
	}
	return rsaPubKey, nil
}

==================================================
File: .\internal\rsa\rsa.go
package rsa
import (
	"bytes"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha1"
	"errors"
	"io"
)
// Cipher represents the RSA cipher with SHA-1 hashing
type Cipher struct {
	privKey *rsa.PrivateKey
	pubKey  *rsa.PublicKey
}
func New(priv *rsa.PrivateKey, pub *rsa.PublicKey) *Cipher {
	return &Cipher{
		privKey: priv,
		pubKey:  pub,
	}
}
func (c *Cipher) Encrypt(in io.Reader) (io.Reader, error) {
	if c.pubKey == nil {
		return nil, errors.New("public key is required for encryption")
	}
	data, err := io.ReadAll(in)
	if err != nil {
		return nil, err
	}
	ciphertext, err := rsa.EncryptOAEP(sha1.New(), rand.Reader, c.pubKey, data, nil)
	if err != nil {
		return nil, err
	}
	return io.NopCloser(bytes.NewReader(ciphertext)), nil
}
func (c *Cipher) Decrypt(in io.Reader) (io.Reader, error) {
	if c.privKey == nil {
		return nil, errors.New("private key is required for decryption")
	}
	ciphertext, err := io.ReadAll(in)
	if err != nil {
		return nil, err
	}
	plaintext, err := rsa.DecryptOAEP(sha1.New(), rand.Reader, c.privKey, ciphertext, nil)
	if err != nil {
		return nil, err
	}
	return io.NopCloser(bytes.NewReader(plaintext)), nil
}

==================================================
